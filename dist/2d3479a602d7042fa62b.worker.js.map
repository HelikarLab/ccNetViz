{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/layout/hierarchical2.worker.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","isOrphan","node","orphan","parents","length","children","self","addEventListener","e","nodes","data","edges","[object Object]","this","_nodes","_edges","alphay","alphax","components","current_component","depth","unvisited","forEach","visited","source","push","target","orphans","roots","isroot","max_outdegree","max_layer","stepy","y","x","maybe_more","layers","lowest_layer","child_found","j","child","layer","sep","parent_found","parent_","component","max_nodes_layer","index_offset","vertical_nodes","current_layer","initializeComponent","next_layer","candidates","includes","layerNodes","initHierarchy","separateOrphans","unvisitedNodes","findRoots","maybe_mode","placeAdditional","stepx","layer_val","k","placeOrphans","layout_options","apply","postMessage"],"mappings":"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","file":"2d3479a602d7042fa62b.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n *  Copyright (c) 2017, Helikar Lab.\n *  All rights reserved.\n *\n *  This source code is licensed under the GPLv3 License.\n *  Author: Renato Fabbri\n */\n\nfunction isOrphan(node){\n    let orphan = true;\n    for (let i=0; i<node.parents.length; ++i){\n        let parent_ = node.parents[i];\n        if (parent_ != node)\n            orphan = false;\n    }\n    for (let i=0; i<node.children.length; ++i){\n        let child = node.children[i];\n        if (child != node)\n            orphan = false;\n    }\n    return orphan;\n}\n\nclass Hierarchical2 {\n  // this layout should handle any digraph\n  constructor(nodes, edges) {\n    this._nodes = nodes;\n    this._edges = edges;\n    this.alphay = 0.05; // y margin\n    this.alphax = 0.05; // x margin\n    this.components = {\"current_component\": 0, \"depth\": 1};\n    this.unvisited = nodes;\n  }\n  \n  initHierarchy(){\n      this._nodes.forEach(function(n,i){\n          n.parents = [];\n          n.children = [];\n          n.visited = false;\n      });\n      this._edges.forEach(function(e,i){\n          e.source.children.push(e.target);\n          e.target.parents.push(e.source);\n      });\n  }\n\n  separateOrphans(){\n      let orphans = [];\n      let nodes = [];\n      for (let i=0; i< this._nodes.length; ++i){\n          let node = this._nodes[i];\n          if (isOrphan(node))\n              orphans.push(node);\n          else\n              nodes.push(node);\n      }\n      return orphans;\n  }\n\n  findRoots(nodes){\n      // find the roots:\n      // nodes defined by the user as roots OR\n      // nodes with in-degree == 0 OR\n      // nodes with greatest in-degree (or degree if undirected graph)\n      let roots = [];\n      for (let i = 0; i < nodes.length; i++){\n          if (nodes[i].isroot == true){ // has to be on the json file of the graph\n              roots.push(nodes[i]);\n          }\n      }\n      if (roots.length == 0){\n          for (let i = 0; i < nodes.length; i++){\n              if (nodes[i].parents.length == 0){\n                  roots.push(nodes[i]);\n              }\n          }\n      }\n      if (roots.length == 0){\n          // calculate max out-degree\n          let max_outdegree = 0;\n          nodes.forEach(function(node){\n              if (node.children.length > max_outdegree){\n                  max_outdegree = node.children.length;\n              }\n          });\n          // choose vertices with greatest out-degree\n          nodes.forEach(function(node){\n              if (node.children.length == max_outdegree){\n                  roots.push(node);\n              }\n          });\n      }\n      return roots;\n  }\n\n  placeOrphans(nodes, max_layer){\n      const stepy = (1 - 2*this.alphay)/(nodes.length-1);\n      for (let i=0; i<nodes.length; ++i){\n          nodes[i].y = this.alphay + i*stepy;\n          nodes[i].x = max_layer+1;\n      }\n      if (nodes.length > 0)\n          return max_layer+1;\n      else\n          return max_layer;\n  }\n\n  unvisitedNodes(){\n      let nodes = [];\n      let orphans = this.orphans;\n      this.unvisited.forEach(function(node){\n          if (node.visited == false && !(node in orphans))\n              nodes.push(node);\n      });\n      if (nodes.length != this.unvisited){\n          this.maybe_more = true;\n          this.unvisited = nodes;\n      } else this.maybe_more = false;\n  }\n\n  placeAdditional(){\n      // place non-visited nodes in between layers\n      let aux_layers = {};\n      let c = this.components[this.components.current_component];\n      let layers = c.layers;\n      for (let i=0; i<this.unvisited.length; ++i){\n          let node = this.unvisited[i];\n          let lowest_layer = this.components.depth;\n          let child_found = false;\n          for(let j=0; j<node.children.length; ++j){\n              let child = node.children[j];\n              if (child.visited == true){\n                  child_found = true;\n                  if(child.layer <= lowest_layer){ // child has to be visited to have a layer\n                      lowest_layer = child.layer;\n                  }\n                  break;\n              }\n          }\n          if (child_found){\n              node.visited = true;\n              // node.index = lowest_layer-sep;\n              if ( !((lowest_layer-sep) in layers))\n                  layers[lowest_layer-sep] = []\n              layers[lowest_layer-sep].push(node)\n          }\n          else {\n              let lowest_layer = max_layer;\n              let parent_found = false;\n              for(let j=0; j<node.parents.length; ++j){\n                  let parent_ = node.parents[j];\n                  if (parent_.visited == true){\n                      parent_found = true;\n                      if(parent_.layer <= lowest_layer){ // child has to be visited to have a layer\n                          lowest_layer = parent_.layer;\n                      }\n                  }\n              }\n              if (parent_found){\n                  node.visited = true;\n                  node.x = lowest_layer+sep;\n                  if ( !((lowest_layer+sep) in layers) )\n                      layers[lowest_layer+sep] = []\n                  layers[lowest_layer+sep].push(node)\n              }\n          }\n      }\n  }\n\n  initializeComponent(component){\n      this.components[component] = {};\n      this.components[component].max_nodes_layer = 0;\n      if (component > 0)\n          this.components[component].index_offset = this.components[component-1].vertical_nodes;\n      else\n          this.components[component].index_offset = 0;\n      this.components[component].current_layer = 1;\n      //this.components[component].layers = {\"nodes\": [], \"layer_value\": 1};\n      this.components[component].layers = {};\n      this.components[component].vertical_nodes = 0;\n  }\n\n  layerNodes(nodes){\n      if (!(this.components.current_component in this.components))\n          this.initializeComponent(this.components.current_component);\n      let c = this.components[this.components.current_component];\n      if (nodes.length > c.vertical_nodes)\n          c.vertical_nodes = nodes.length;\n      c.layers[c.current_layer] = [];\n      for (let i=0; i<nodes.length; ++i){\n          nodes[i].visited = true;\n          c.layers[c.current_layer].push(nodes[i]);\n      }\n      let next_layer = [];\n      for (let i=0; i<nodes.length; i++){\n          let candidates = nodes[i].children;\n          for (let j=0; j < candidates.length; j++){\n              if (candidates[j].visited == false && !next_layer.includes(candidates[j])){\n                  next_layer.push(candidates[j]);\n              }\n          }\n      }\n      if (next_layer.length > 0){\n          c.current_layer++;\n          if (this.components.depth<c.current_layer)\n              this.components.depth = c.current_layer;\n          this.layerNodes(next_layer);\n      }\n  }\n\n  apply () {\n      // left-right tree by default, let user choose\n      // top-down, bottom-top, right-left in subsequent versions\n      // hierarchical layouts for trees (acyclic graphs) are\n      // implemented separately for now\n\n      // number of layers and max number of nodes in each layer\n      // has to be found by making the layout\n      // there are two approaches to finding the nodes in each layer:\n      // 1) each layer has all the neighbors of the nodes in the previous layer\n      // 2) follow links and then place non visited nodes on the layer of neighbors OR\n      // this layout implements the second of these approaches.\n\n      this.initHierarchy();\n      this.orphans = this.separateOrphans();\n      this.unvisitedNodes();\n      while (this.unvisited.length > 0){\n          let roots = this.findRoots(this.unvisited);\n          this.layerNodes(roots);\n          this.unvisitedNodes(); // update unvisited nodes\n          this.maybe_mode = true;\n          while (this.maybe_more){\n              this.placeAdditional(); // place additional nodes linked to this component\n              this.unvisitedNodes(); // update unvisited nodes\n          }\n          this.components.current_component++;\n      }\n      this.components.vertical_nodes = 0;\n      for (let i=0; i<this.components.current_component; i++){\n          this.components.vertical_nodes += this.components[i].vertical_nodes;\n      }\n\n      // layerNodes should populate the dictionary this.components of components and aux variables:\n      // components[x] is a component, x is an integer\n      // components[x].vertical_nodes is the maximum number of nodes in a layer for the component\n      // components[x].layer[j] is the j-th layer on the component, j can be fractional\n      // components[x].index_offset is the number of nodes positioned in above components\n      // components.ncomponents is the number of components\n      // components.vertical_nodes is the sum of the max nodes in any layer of each component\n      // components.depth is the maximum number of layers\n\n      // each layer of tree xy = [0+alpha,1-alpha]\n      const stepx = (1-2*this.alphax)/(this.components.depth);\n      const stepy = (1-2*this.alphay)/(this.components.vertical_nodes);\n      for (let i=0; i<this.components.current_component; i++){\n          let component = this.components[i];\n          for (let layer_val in component.layers){\n              let layer = component.layers[layer_val];\n              if (layer.length == 1){\n                  let node = layer[0];\n                  node.x = this.alphax + stepx*layer_val;\n                  node.y = this.alphay + stepy*(component.index_offset + component.vertical_nodes/2);\n              } else {\n                  for (let k=0; k<layer.length; ++k){\n                      let node = layer[k];\n                      node.x = this.alphax + stepx*layer_val;\n                      node.y = this.alphay + stepy*(component.index_offset + k);\n                  }\n              }\n          }\n      }\n      this.placeOrphans(this.orphans);\n  }\n};\n\nself.addEventListener('message', function (e) {\n    var nodes = e.data.nodes;\n    var edges = e.data.edges;\n    var layout_options = e.data.layout_options;\n    new Hierarchical2(nodes, edges, layout_options).apply();\n    self.postMessage({ nodes, edges });\n}, false);"],"sourceRoot":""}